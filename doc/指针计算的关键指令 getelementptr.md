# 指针计算的关键指令 getelementptr

```llvm
<result> = getelementptr <ty>, <ty>* <ptrval>, {<ty> <index>}*
```

需要解释的是等号右侧的部分：

* 第一个 `<ty>` 表明第一个索引的所指向的类型
* 第二个 `<ty>`* 表明 `<ptrval>` 的类型，后者是指针基址
* 后面有若干对 `<ty> <index>` ，每组索引的类型和值，表征对应维度上的偏移量（下面会解释“对应维度”）

下面用两个栗子来陈述更为清晰

```
@a_gv = global [6 x i8] zeroinitializer
%new_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0
%elem_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0, i32 1
```

对于 `new_ptr`，其第一个偏移量为 0，其实感觉 `<ty> <index>` 中的 `<ty>` 没什么特别的意义，作为 index 的类型，也只能是 i32。这里所谓的第一个偏移量，其偏移的单位长度其实并非数组的第一维，而是数组本身。对于我们平常所说的数组，譬如可以假设 `a[2][2]` 第一个偏移量为 0，指的并非是 `a[0]` ，而是以整个数组的规模为偏移单位。

![image-20221121213428747](https://20220923img.oss-cn-hangzhou.aliyuncs.com/markdown/image-20221121213428747.png)

如图，我们定义的 a_gv 实际上是一个一维数组，但是如果第一个偏移量为1，则实际偏移增加量为 `1 x [6 x i8]` 也就是指向了上图中第 7 个元素。但是例子中是 0，所以如图所示，指向的是第一个元素。从这个意义上，第一个偏移量也可以理解为 “平辈偏移”，与C语言中 `a[1] = *(a + 1)` 倒有所联系。

对于 `elem_ptr` 增加了一维偏移量。对于 `getelementptr` 而言，后面接着的几个偏移量，其实是不同维数的偏移量，**每增加一个偏移量，偏移量对应的维度就下降一维**。 `elem_ptr` 后有两个偏移量，偏移量总量为 `0 x [6 x i8] + 1 x i8` ，因此指针指向第一行第二个元素。同时需要注意的是，**每增加一个偏移量，返回值也会下降一维**。

```
@a = global [5 x [4 x i32]] zeroinitializer
%1 = getelementptr [5 x [4 x i32]], [5 x [4 x i32]]* @a, i32 0, i32 2, i32 3 
```

对于这个例子，其偏移总量为 `0 x [5 x [4 x i32]] + 2 x [4 x i32] + 3 x i32`，实际含义就是获取 `a[5][4]` 的 `a[2][3]`.