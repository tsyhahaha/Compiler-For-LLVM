# 符号表的构建

在重构AST的过程中，需要同时构建符号表。

查表对象有二，变量 与 函数。对于变量而言，若说道对符号表的要求，则集中在 Expr 和 DeclStmt 中；对于函数而言，也需要 DeclStmt 进行填表，以及 CallExpr 调用。

## 一、变量

VarDeclStmt 类，需要增加对变量的定义，至于需要定义哪些信息，则需要根据后文以及错误处理的要求了。

### 1、类的填表需求

填表只有 VarDeclStmt 会进行，并将信息存在 VarDecl 实体中。

此处涉及的错误处理内容有：

| 错误类型      | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| b：名词重定义 | 变量名在当前作用域下重复，变量名词重复一定是同一级作用域才会报错 |

涉及信息：变量名

### 2、类的查表需求

用表事实上就是查表，对于计算类的表达式，只需要**查询变量所在寄存器**即可。

此处涉及的错误处理内容有：

| 错误类型            | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| c：未定义的名词     | 其实就是在表中找不到该变量名                                 |
| h：不能改变常量的值 | 赋值语句的时候需要查询左侧符号的类型（即使赋相同的值也不行） |

涉及信息：变量名，变量类型（const，var）。

## 二、函数

FuncDeclStmt 类，需要在全局符号表中填入函数原型的定义，以供后续查询，对于函数体 CompoundStmt 则需另构建符号表，并指向全局符号表。

### 1、类的填表需求

填表只有 FuncDeclStmt 会进行，并将信息存在 FuncDecl 实体中。

此处涉及的错误处理内容有：

| 错误类型      | 解释                 |
| ------------- | -------------------- |
| b：名词重定义 | 不能有相同名字的函数 |

涉及信息：函数名

### 2、类的查表需求

用函数，只有 CallExpr 语句：

`call void @use(i32 %sum)`

可以看出，最基本的信息需求是：返回值类型，参数类型，函数名。

此处涉及的错误处理内容有：

| 错误类型                                                     | 解释 |
| ------------------------------------------------------------ | ---- |
| d：函数参数个数不匹配                                        |      |
| e：函数参数类型不匹配                                        |      |
| f：无返回值函数存在不匹配的 return 语句 / g：有返回值的函数缺少 return 语句 |      |
| I：printf 参数个数不匹配                                     |      |

涉及信息：返回值类型，参数类型，函数名。

---

综上所述，符号表对变量的信息需求为：变量名，变量类型，变量所储存的寄存器；对函数的信息需求为：函数名，返回值类型，参数类型。